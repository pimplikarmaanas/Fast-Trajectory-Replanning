import random
import sys
import inspect
import time
from multiprocessing import Pool

# default dimensions of a graph generated by generate_graph
TEST_GRAPH_DIM = 101

class Cell:
    def __init__(self):
        self.__blocked = False

    def __str__(self):
        return str(self.__blocked)

    def set_blocked(self, status: bool):
        self.__blocked = status

    def is_blocked(self):
        return self.__blocked

class Graph:
    def __init__(self, label: int, len: int):
        self.label = label
        self.__len = len
        self.__graph = []
        for i in range(len):
            row = []
            for j in range(len):
                row.append(Cell())
            self.__graph.append(row)

    def __str__(self):
        res = ""
        for i in range(len(self.__graph)):
            for j in range(len(self.__graph[i])):
                res += f"|{str(self.__graph[i][j])[0]}| "
            res += "\n"
        return res

    def __getitem__(self, cell: tuple):
        row, col = cell[0], cell[1]
        return self.__graph[row][col]
    
    def __setitem__(self, cell: tuple, val: Cell):
        row, col = cell[0], cell[1]
        self.__graph[row][col] = val
    
    def get_dim(self):
        return len(self.__graph)
    
    def get_label(self):
        return self.label

    def set_cell_status(self, cell: tuple, status: bool):
        row, col = cell[0], cell[1]
        self.__graph[row][col].set_blocked(status)

class Maze:
    def __init__(self):
        pass

    # private helper function used in get_random_graph
    def __flood_fill(self, g: Graph, cell: tuple, visited: set):
        # to prevent hitting the recursion limit with base limit = 1000
        def random_status():
            r = random.randint(1, 100)
            return True if r <= 30 else False

        def get_neighbors(cell: tuple):
            x, y, res = cell[0], cell[1], []
            # left
            if x-1 >= 0 and (x-1, y) not in visited:
                res.append((x-1, y))
            # right
            if x+1 < g.get_dim() and (x+1, y) not in visited:
                res.append((x+1, y))
            # down
            if y+1 < g.get_dim() and (x, y+1) not in visited:
                res.append((x, y+1))
            # up
            if y-1 >= 0 and (x, y-1) not in visited:
                res.append((x, y-1))

            return res
        
        neighbors = get_neighbors(cell)
        if not neighbors:
            return

        for c in neighbors:
            if c not in visited:
                g.set_cell_status(c, random_status())
                visited.add(c)
                self.__flood_fill(g, c, visited)

    # returns a randomly initialized graph with the passed in label
    def generate_graph(self, label: int, **kwargs):
        dim = kwargs.get("dim", TEST_GRAPH_DIM)
        g = Graph(label, dim)

        start_t = time.perf_counter()

        available_cells = []
        # adding all possible cells to the list
        for i in range(dim):
            for j in range(dim):
                available_cells.append((i,j))
        
        visited = set()
        while available_cells:
            chosen_cell = random.choice(available_cells) # randomly chosen cell

            # mark as visited and remove from list
            visited.add(chosen_cell)
            available_cells.remove(chosen_cell)
            
            g[(chosen_cell)].set_blocked(False)

            self.__flood_fill(g, chosen_cell, visited)
            available_cells = list(set(available_cells) - visited)

        end_t = time.perf_counter()
        return g, end_t - start_t

    def get_testing_graphs(self, *, count: int):
        graphs = []
        start_t = time.perf_counter()

        with Pool(processes=10) as pool:
            results = pool.imap_unordered(self.generate_graph, range(1, count+1))

            for g, duration in results:
                graphs.append(g)
                print(f"{g.get_label()} completed in {duration} seconds")
        
        end_t = time.perf_counter()
        time_taken = end_t - start_t
        print(f"All graphs generated\nTotal time taken: {time_taken}")
        return graphs
